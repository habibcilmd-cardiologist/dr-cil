{{/* 3D Heart Model Viewer Partial */}}
<div
	id="heart-model-container"
	style="width: 100%; height: 100%; min-height: 400px"
>
	<div
		id="heart-viewer"
		style="
			width: 100%;
			height: 100%;
			background-color: transparent;
			border-radius: 12px;
			overflow: hidden;
			position: relative;
		"
	>
		<div
			id="heart-loading"
			style="
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				color: #333;
				font-family: sans-serif;
				font-size: 1.2rem;
				pointer-events: none;
			"
		>
			{{ i18n "heart_model_loading" | default "Loading Heart Model..." }}
		</div>
		<div
			style="
				position: absolute;
				bottom: 20px;
				right: 20px;
				color: rgba(0, 0, 0, 0.5);
				font-family: sans-serif;
				font-size: 0.8rem;
				pointer-events: none;
			"
		>
			{{ i18n "heart_model_hint" | default "Drag to Rotate â€¢ Scroll to Zoom" }}
		</div>
	</div>
</div>

<script type="module">
	import * as THREE from "https://cdn.skypack.dev/three@0.132.2";
	import { GLTFLoader } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/GLTFLoader.js";
	import { OrbitControls } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js";

	const container = document.getElementById("heart-viewer");
	const loadingText = document.getElementById("heart-loading");
	const hintText = document.querySelector("#heart-viewer > div:last-child");

	// Dark mode detection
	const isDarkMode = () => document.documentElement.classList.contains('dark');
	
	// Colors for light and dark mode
	const lightBg = 0xffffff;
	const darkBg = 0x1f2937; // Tailwind gray-800
	
	// Update colors based on theme
	const updateThemeColors = () => {
		const dark = isDarkMode();
		const bgColor = dark ? darkBg : lightBg;
		
		scene.background = new THREE.Color(bgColor);
		scene.fog = new THREE.Fog(bgColor, 20, 100);
		
		// Update text colors
		loadingText.style.color = dark ? "#e5e7eb" : "#333";
		hintText.style.color = dark ? "rgba(255, 255, 255, 0.5)" : "rgba(0, 0, 0, 0.5)";
	};

	// Scene setup
	const scene = new THREE.Scene();
	scene.background = new THREE.Color(isDarkMode() ? darkBg : lightBg);
	scene.fog = new THREE.Fog(isDarkMode() ? darkBg : lightBg, 20, 100);
	
	// Initial text color setup
	loadingText.style.color = isDarkMode() ? "#e5e7eb" : "#333";
	hintText.style.color = isDarkMode() ? "rgba(255, 255, 255, 0.5)" : "rgba(0, 0, 0, 0.5)";

	const camera = new THREE.PerspectiveCamera(
		45,
		container.clientWidth / container.clientHeight,
		0.1,
		1000
	);
	camera.position.z = 5;
	camera.position.y = 0;

	const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
	renderer.setSize(container.clientWidth, container.clientHeight);
	renderer.setPixelRatio(window.devicePixelRatio);
	// Enable shadow map for better realism
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	// Output encoding to sRGB for better color accuracy with GLTF
	renderer.outputEncoding = THREE.sRGBEncoding;
	container.appendChild(renderer.domElement);

	// Controls
	const controls = new OrbitControls(camera, renderer.domElement);
	controls.enableDamping = true;
	controls.dampingFactor = 0.05;
	controls.enableZoom = true;
	controls.autoRotate = true;
	controls.autoRotateSpeed = 1.0;

	// Lights
	const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // Bright ambient
	scene.add(ambientLight);

	const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); // Main sun light
	dirLight.position.set(5, 10, 7);
	dirLight.castShadow = true;
	scene.add(dirLight);

	const fillLight = new THREE.DirectionalLight(0xe3e3e3, 1.0); // Fill light from opposite side
	fillLight.position.set(-5, 0, 5);
	scene.add(fillLight);

	// Load Model
	const loader = new GLTFLoader();
	loader.load(
		"/models/3d-kalp-modeli-doc-dr-habib-cil-istanbul-kardiyoloji-uzmani.glb",
		function (gltf) {
			const object = gltf.scene;

			// Center the model geometry
			const box = new THREE.Box3().setFromObject(object);
			const center = box.getCenter(new THREE.Vector3());
			object.position.sub(center); // Move object so its center is at (0,0,0)

			// Traverse to enable shadows
			object.traverse(function (node) {
				if (node.isMesh) {
					node.castShadow = true;
					node.receiveShadow = true;
				}
			});

			scene.add(object);

			// Robust camera fitting
			const fitCameraToSelection = function (
				camera,
				controls,
				selection,
				fitOffset = 1.2
			) {
				const box = new THREE.Box3();
				box.setFromObject(selection);
				const size = box.getSize(new THREE.Vector3());
				const center = box.getCenter(new THREE.Vector3());

				const maxSize = Math.max(size.x, size.y, size.z);
				const fitHeightDistance =
					maxSize / (2 * Math.atan((Math.PI * camera.fov) / 360));
				const fitWidthDistance = fitHeightDistance / camera.aspect;
				const distance =
					fitOffset * Math.max(fitHeightDistance, fitWidthDistance);

				const direction = controls.target
					.clone()
					.sub(camera.position)
					.normalize()
					.multiplyScalar(distance);

				controls.maxDistance = distance * 10;
				controls.target.copy(center);

				camera.near = distance / 100;
				camera.far = distance * 100;
				camera.updateProjectionMatrix();

				camera.position.copy(controls.target).sub(direction);
				controls.update();
			};

			// Call fit camera
			fitCameraToSelection(camera, controls, object, 1.1); // 1.5 gives more zoomed out view (larger offset = smaller model)

			loadingText.style.display = "none";
		},
		function (xhr) {
			if (xhr.lengthComputable) {
				const percentComplete = (xhr.loaded / xhr.total) * 100;
				loadingText.innerText = `Loading... ${Math.round(
					percentComplete
				)}%`;
			}
		},
		function (error) {
			console.error("An error happened", error);
			loadingText.innerText = "Error loading model";
			loadingText.style.color = "red";
		}
	);

	// Check for resize on init to fix potential initial size issues
	setTimeout(() => {
		if (container) {
			camera.aspect = container.clientWidth / container.clientHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(container.clientWidth, container.clientHeight);
		}
	}, 100);

	// Animation Loop
	function animate() {
		requestAnimationFrame(animate);
		controls.update();
		renderer.render(scene, camera);
	}

	animate();

	// Handle Resize
	window.addEventListener("resize", function () {
		if (container) {
			camera.aspect = container.clientWidth / container.clientHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(container.clientWidth, container.clientHeight);
		}
	});

	// Watch for dark mode changes
	const observer = new MutationObserver((mutations) => {
		mutations.forEach((mutation) => {
			if (mutation.attributeName === 'class') {
				updateThemeColors();
			}
		});
	});
	
	observer.observe(document.documentElement, {
		attributes: true,
		attributeFilter: ['class']
	});
</script>
